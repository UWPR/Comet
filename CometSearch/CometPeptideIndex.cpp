// Copyright 2023 Jimmy Eng
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


#include "CometPeptideIndex.h"

extern comet_fileoffset_t clSizeCometFileOffset;


CometPeptideIndex::CometPeptideIndex()
{
}

CometPeptideIndex::~CometPeptideIndex()
{
}


bool CometPeptideIndex::WritePeptideIndex(ThreadPool *tp)
{
   bool bSucceeded;
   FILE *fptr;

   const int iIndex_SIZE_FILE=SIZE_FILE+4;
   char szIndexFile[iIndex_SIZE_FILE];
   sprintf(szIndexFile, "%s.idx", g_staticParams.databaseInfo.szDatabase);

   if ((fptr = fopen(szIndexFile, "wb")) == NULL)
   {
      printf(" Error - cannot open index file %s to write\n", szIndexFile);
      exit(1);
   }

   logout(" Creating peptide index file: ");
   fflush(stdout);

   bSucceeded = CometSearch::AllocateMemory(g_staticParams.options.iNumThreads);

   // these are used in call to RunSearch to generate peptides
   g_massRange.dMinMass = g_staticParams.options.dPeptideMassLow;
   g_massRange.dMaxMass = g_staticParams.options.dPeptideMassHigh;

   if (g_massRange.dMaxMass - g_massRange.dMinMass > g_massRange.dMinMass)
      g_massRange.bNarrowMassRange = true;
   else
      g_massRange.bNarrowMassRange = false;

   if (bSucceeded)
   {
      bSucceeded = CometSearch::RunSearch(0, 0, tp);
   }

   if (!bSucceeded)
   {
      std::string strErrorMsg = " Error in RunSearch() for peptide index creation.\n";
      logerr(strErrorMsg);
      CometSearch::DeallocateMemory(g_staticParams.options.iNumThreads);
      return false;
   }

   // sanity check
   if (g_pvDBIndex.size() == 0)
   {
      std::string strErrorMsg = " Error: no peptides in index; check the input database file or search parameters.\n";
      logerr(strErrorMsg);
      CometSearch::DeallocateMemory(g_staticParams.options.iNumThreads);
      return false;
   }

   // remove duplicates
   logout(" - removing duplicates\n");
   fflush(stdout);

   // keep unique entries only; sort by peptide/modification state and protein
   // first sort by peptide, then mod state, then protein file position
   sort(g_pvDBIndex.begin(), g_pvDBIndex.end(), CometMassSpecUtils::DBICompareByPeptide);

   // At this point, need to create pvProteinsListLocal protein file position vector of vectors to map each peptide
   // to every protein. g_pvDBIndex.at().lProteinFilePosition is now reference to protein vector entry.
   // When reading the peptide index file as part of the first call to SearchPeptideIndex(), this vector of vectors
   // will be stored in g_pvProteinsList to be used in the search.
   std::vector<std::vector<comet_fileoffset_t>> pvProteinsListLocal;
   std::vector<comet_fileoffset_t> temp;  // stores list of duplicate proteins which gets pushed to pvProteinsListLocal

   // Create pvProteinsListLocal.  This is a vector of vectors.  Each element is vector list
   // of duplicate proteins (generated as "temp") ... these are generated by looping
   // through g_pvDBIndex and looking for consecutive, same peptides.  Once the "temp"
   // vector is assigned the lIndexProteinFilePosition offset, the g_pvDBIndex entry
   // sets lIndexProteinFilePosition to lProtCount which references which vector of
   // proteins the peptide is contained in.
   long lProtCount = 0;
   for (size_t i = 0; i < g_pvDBIndex.size(); i++)
   {
      if (i == 0)
      {
         temp.push_back(g_pvDBIndex.at(i).lIndexProteinFilePosition);
         g_pvDBIndex.at(i).lIndexProteinFilePosition = lProtCount;
      }
      else
      {
         // each unique peptide, irregardless of mod state, will have the same list
         // of matched proteins
         if (!strcmp(g_pvDBIndex.at(i).szPeptide, g_pvDBIndex.at(i-1).szPeptide))
         {
            temp.push_back(g_pvDBIndex.at(i).lIndexProteinFilePosition);
            g_pvDBIndex.at(i).lIndexProteinFilePosition = lProtCount;
         }
         else
         {
            // different peptide + mod state so go ahead and push temp onto pvProteinsListLocalk
            // and store current protein reference into new temp
            // temp can have duplicates due to mod forms of peptide so make unique here
            sort(temp.begin(), temp.end());
            temp.erase(unique(temp.begin(), temp.end()), temp.end() );
            pvProteinsListLocal.push_back(temp);

            lProtCount++; // start new row in pvProteinsListLocal
            temp.clear();
            temp.push_back(g_pvDBIndex.at(i).lIndexProteinFilePosition);
            g_pvDBIndex.at(i).lIndexProteinFilePosition = lProtCount;
         }
      }
   }
   // now at end of loop, push last temp onto pvProteinsListLocal
   sort(temp.begin(), temp.end());
   temp.erase(unique(temp.begin(), temp.end()), temp.end() );
   pvProteinsListLocal.push_back(temp);

   // JKE FIX:  Currently g_vProteinsList has an entry for every peptide and there
   // can be duplicates set of file pointers in g_vProteinsList.  Ideally each entry
   // in g_vProteinsList is a unique set of file pointers which means a bit of
   // optimization needs to happen to here (granted resulting only in storage/ram
   // savings for the reduced size of g_vProteinsList).

   sort(g_pvDBIndex.begin(), g_pvDBIndex.end());  // sort by peptide sequence, mod state, protein file position
   g_pvDBIndex.erase(unique(g_pvDBIndex.begin(), g_pvDBIndex.end()), g_pvDBIndex.end());

   // sort by mass;
   sort(g_pvDBIndex.begin(), g_pvDBIndex.end(), CometMassSpecUtils::DBICompareByMass);

/*
   printf("OK unique peptide index entries:\n");
   for (std::vector<DBIndex>::iterator it = g_pvDBIndex.begin(); it != g_pvDBIndex.end(); ++it)
   {
      if ((*it).pcVarModSites[strlen((*it).szPeptide)] != 0)
         printf("n%d", (*it).pcVarModSites[strlen((*it).szPeptide)] - 1);
      for (unsigned int x = 0; x < strlen((*it).szPeptide); x++)
      {
         printf("%c", (*it).szPeptide[x]);
         if ((*it).pcVarModSites[x] != 0)
            printf("%d", (*it).pcVarModSites[x] - 1);
      }
      if ((*it).pcVarModSites[strlen((*it).szPeptide) + 1] != 0)
         printf("c%d", (*it).pcVarModSites[strlen((*it).szPeptide)] - 1);
      printf("\t%f\t%lld\t%d\n", (*it).dPepMass, (*it).lIndexProteinFilePosition,(*it).siVarModProteinFilter);
   }
   printf("\n");
*/

   logout(" - writing file\n");
   fflush(stdout);

   // write out index header
   fprintf(fptr, "Comet peptide index database.  Comet version %s\n", g_sCometVersion.c_str());
   fprintf(fptr, "InputDB:  %s\n", g_staticParams.databaseInfo.szDatabase);
   fprintf(fptr, "MassRange: %lf %lf\n", g_staticParams.options.dPeptideMassLow, g_staticParams.options.dPeptideMassHigh);
   fprintf(fptr, "LengthRange: %d %d\n", g_staticParams.options.peptideLengthRange.iStart, g_staticParams.options.peptideLengthRange.iEnd);
   fprintf(fptr, "MassType: %d %d\n", g_staticParams.massUtility.bMonoMassesParent, g_staticParams.massUtility.bMonoMassesFragment);
   fprintf(fptr, "Enzyme: %s [%d %s %s]\n", g_staticParams.enzymeInformation.szSearchEnzymeName,
      g_staticParams.enzymeInformation.iSearchEnzymeOffSet,
      g_staticParams.enzymeInformation.szSearchEnzymeBreakAA,
      g_staticParams.enzymeInformation.szSearchEnzymeNoBreakAA);
   fprintf(fptr, "Enzyme2: %s [%d %s %s]\n", g_staticParams.enzymeInformation.szSearchEnzyme2Name,
      g_staticParams.enzymeInformation.iSearchEnzyme2OffSet,
      g_staticParams.enzymeInformation.szSearchEnzyme2BreakAA,
      g_staticParams.enzymeInformation.szSearchEnzyme2NoBreakAA);
   fprintf(fptr, "NumPeptides: %ld\n", (long)g_pvDBIndex.size());

   // write out static mod params A to Z is ascii 65 to 90 then terminal mods
   fprintf(fptr, "StaticMod:");
   for (int x = 65; x <= 90; x++)
      fprintf(fptr, " %lf", g_staticParams.staticModifications.pdStaticMods[x]);
   fprintf(fptr, " %lf", g_staticParams.staticModifications.dAddNterminusPeptide);
   fprintf(fptr, " %lf", g_staticParams.staticModifications.dAddCterminusPeptide);
   fprintf(fptr, " %lf", g_staticParams.staticModifications.dAddNterminusProtein);
   fprintf(fptr, " %lf\n", g_staticParams.staticModifications.dAddCterminusProtein);

   // write out variable mod params
   fprintf(fptr, "VariableMod:");
   for (int x = 0; x < VMODS; x++)
   {
      fprintf(fptr, " %s:%lf:%lf:%lf",
            g_staticParams.variableModParameters.varModList[x].szVarModChar,
            g_staticParams.variableModParameters.varModList[x].dVarModMass,
            g_staticParams.variableModParameters.varModList[x].dNeutralLoss,
            g_staticParams.variableModParameters.varModList[x].dNeutralLoss2);

   }
   fprintf(fptr, "\n\n");

   // Now write out: vector<vector<comet_fileoffset_t>> pvProteinsListLocal
   comet_fileoffset_t clProteinsFilePos = comet_ftell(fptr);
   size_t tTmp = pvProteinsListLocal.size();
   fwrite(&tTmp, clSizeCometFileOffset, 1, fptr);
   for (auto it = pvProteinsListLocal.begin(); it != pvProteinsListLocal.end(); ++it)
   {
      tTmp = (*it).size();
      fwrite(&tTmp, sizeof(size_t), 1, fptr);
      for (size_t it2 = 0; it2 < tTmp; ++it2)
      {
         fwrite(&((*it).at(it2)), clSizeCometFileOffset, 1, fptr);
      }
   }

   // next write out the peptides and track peptide mass index
   int iMaxPeptideMass = (int)(g_staticParams.options.dPeptideMassHigh);
   int iMaxPeptideMass10 = iMaxPeptideMass * 10;  // make mass index at resolution of 0.1 Da
   comet_fileoffset_t *lIndex = new comet_fileoffset_t[iMaxPeptideMass10 + 1];
   for (int x = 0; x <= iMaxPeptideMass10; x++)
      lIndex[x] = -1;

   // write out peptide entry here
   int iPrevMass10 = 0;
   for (std::vector<DBIndex>::iterator it = g_pvDBIndex.begin(); it != g_pvDBIndex.end(); ++it)
   {
      if ((int)((*it).dPepMass * 10.0) > iPrevMass10)
      {
         iPrevMass10 = (int)((*it).dPepMass * 10.0);
         if (iPrevMass10 < iMaxPeptideMass10)
            lIndex[iPrevMass10] = comet_ftell(fptr);
      }

      int iLen = (int)strlen((*it).szPeptide);
      fwrite(&iLen, sizeof(int), 1, fptr);
      fwrite((*it).szPeptide, sizeof(char), iLen, fptr);

      // write out for char 0=no mod, N=mod.  If N, write out var mods as N pairs (pos,whichmod)
      int iLen2 = iLen + 2;
      unsigned char cNumMods = 0; 
      for (unsigned char x=0; x<iLen2; x++)
      {
         if ((*it).pcVarModSites[x] != 0)
            cNumMods++;
      }
      fwrite(&cNumMods, sizeof(unsigned char), 1, fptr);

      if (cNumMods > 0)
      {
         for (unsigned char x=0; x<iLen2; x++)
         {
            if ((*it).pcVarModSites[x] != 0)
            {
               char cWhichMod = (*it).pcVarModSites[x];
               fwrite(&x, sizeof(unsigned char), 1, fptr);
               fwrite(&cWhichMod , sizeof(char), 1, fptr);
            }
         }
      }
      // done writing out mod sites

      fwrite(&((*it).dPepMass), sizeof(double), 1, fptr);
      fwrite(&((*it).lIndexProteinFilePosition), sizeof(comet_fileoffset_t), 1, fptr);
   }

   comet_fileoffset_t lEndOfPeptides = comet_ftell(fptr);

   int iTmpCh = (int)(g_staticParams.options.dPeptideMassLow);
   fwrite(&iTmpCh, sizeof(int), 1, fptr);  // write min mass
   fwrite(&iMaxPeptideMass, sizeof(int), 1, fptr);  // write max mass
   uint64_t tNumPeptides = g_pvDBIndex.size();
   fwrite(&tNumPeptides, sizeof(uint64_t), 1, fptr);  // write # of peptides
   fwrite(lIndex, clSizeCometFileOffset, iMaxPeptideMass10, fptr); // write index
   fwrite(&lEndOfPeptides, clSizeCometFileOffset, 1, fptr);  // write ftell position of min/max mass, # peptides, peptide index
   fwrite(&clProteinsFilePos, clSizeCometFileOffset, 1, fptr);

   fclose(fptr);

   std::string strNumPeps;
   if (tNumPeptides > 1e6)
   {
      std::ostringstream oss;
      oss << std::scientific << std::setprecision(3) << static_cast<double>(tNumPeptides);
      strNumPeps = oss.str();
   }
   else
   {
      strNumPeps = std::to_string(tNumPeptides);
   }

   std::string strOut = " - done. " + std::string(szIndexFile) + " (" + strNumPeps + " peptides)\n\n";
   logout(strOut);
   fflush(stdout);

   CometSearch::DeallocateMemory(g_staticParams.options.iNumThreads);

   g_pvDBIndex.clear();
   delete[] lIndex;

   return bSucceeded;
}


void CometPeptideIndex::ReadPeptideIndexEntry(struct DBIndex *sDBI, FILE *fp)
{
   int iLen;
   size_t tTmp;

   tTmp = fread(&iLen, sizeof(int), 1, fp);
   tTmp = fread(sDBI->szPeptide, sizeof(char), iLen, fp);
   sDBI->szPeptide[iLen] = '\0';

   unsigned char cNumMods;  // number of var mods encoded as position:residue pairs
   tTmp = fread(&cNumMods, sizeof(unsigned char), 1, fp);  // read how many var mods are stored

   memset(sDBI->pcVarModSites, 0, sizeof(unsigned char)*iLen+2);
   if (cNumMods > 0)
   {
      for (unsigned char x=0; x<cNumMods; x++)
      {
         unsigned char cPosition;
         char cResidue;
         tTmp = fread(&cPosition, sizeof(unsigned char), 1, fp);
         tTmp = fread(&cResidue, sizeof(char), 1, fp);
         sDBI->pcVarModSites[(int)cPosition] = cResidue;
      }
   }
   // done reading mod sites

   tTmp = fread(&(sDBI->dPepMass), sizeof(double), 1, fp);
   tTmp = fread(&(sDBI->lIndexProteinFilePosition), sizeof(comet_fileoffset_t), 1, fp);
}
